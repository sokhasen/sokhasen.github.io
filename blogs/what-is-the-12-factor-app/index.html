<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>What is The Twelve-Factor App?</title>
    <link rel="stylesheet" href="../../assets/style.css">
    <style>
        p {
            margin-bottom: 1.5rem;
            text-indent: 2.5rem;
        }

        h2 {
            font-size: 24px;
            font-weight: bold;
            margin-top: 2rem;
            margin-bottom: 2rem;
        }
    </style>
</head>

<body class="font-body2 text-gray-700">
    <div class="bg-white p-4 text-center border-b border-gray-100">
        <a href="/" class="font-semibold">HOME</a>
        <a href="/blogs" class="font-semibold  ml-4">BLOG</a>
    </div>
    <div class="relative">
        <img class="w-full h-40 md:h-80 object-cover"
            src="https://eleks.com/wp-content/uploads/tokenization-vs-encryption.jpg">
    </div>
    <div class="w-11/12 md:w-7/12 lg:w-7/12 mx-auto my-6 md:my-12">
        <div class="relative">
            <div class="flex items-center justify-between  flex-col md:flex-row">
                <div class="flex items-center flex-col md:flex-row">
                    <img class=" rounded-full w-14 h-14" src="https://avatars.githubusercontent.com/u/26691076?v=4"
                        alt="https://avatars.githubusercontent.com/u/26691076?v=4"
                        srcset="https://avatars.githubusercontent.com/u/26691076?v=4">
                    <span class="font-bold text-md md:ml-5">Sokha Sen</span>
                </div>
                <div class="flex flex-col justify-between md:items-end mt-2">
                    <div class="text-sm">Tuesday 28, April 2020</div>
                    <div class="py-21></div>
                    <div class=" text-sm">Software Engineering |
                        Software Architecture |
                        Database</div>
                </div>
            </div>

            <article class="mt-10 md:mt-20">
                <div class="my-10">
                    <h2>12 Factor App Example In Spring Boot</h2>
                </div>
                <p class="mb-6">
                    Building web applications deploy on a modern cloud environment and delivered as a service called
                    software-as-a-service. It is important to find methodology to architect web apps that fit on cloud
                    computing and deliver software on time. In 2011, <a class="text-blue-500"
                        href="https://github.com/adamwiggins" target="_blank"> Adam
                        Wiggins</a>, developer at heroku, drafted the
                    twelve-factor app methodology. He defined and separated 12 factors helping maximum portability,
                    clean contract, scale up, continuous deployment.
                </p>

                <!-- content -->
                <h2>1 - Codebase</h2>
                <blockquote class="blockquote bg-gray-50 text-gray-400 py-3 mb-6 rounded-sm">
                    <p class="mb-0">

                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mb-1" fill="none"
                            viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <span class="ml-2 text-lg font-bold">One codebase tracked in revision control, many
                            deploys</span>
                    </p>
                </blockquote>
                <p>
                    12 factor app methodology strongly defines that <b>an application on many different deploy
                        environments must have only a single codebase</b>, tracked in a version control system such as
                    git,
                    or subvision. Codebase is a set of instructions of your application on any single repository.
                </p>

                <p>
                    In order to comply with this principle, we keep our one codebase per app in the git version
                    control system and share many deploys of the app. If we have multiple codebases, it is called a
                    distributed system. 12 Factor App recommended us to apply a single codebase per component. If we
                    have a multi app that has shared the same codebase, we must wrap it into libraries which are
                    included through the dependency manager.
                </p>

                <p>
                    In the real example practice with our spring boot application, we keep our source code in the
                    git repository and share them to our collaborations. This code will be compiled and packaged
                    then deployed to one or many environments. For specific running applications in different
                    environments like development, production, it depends on configuration. We store those
                    configurations using spring profiles and environment specific properties rather than duplicate
                    our code base into different repositories. Test, staging, prod must have one source code base in
                    one repository.
                </p>

                <h2>2 - Dependencies</h2>
                <blockquote class="blockquote bg-gray-50 text-gray-400 py-3 mb-6 rounded-sm">
                    <p class="mb-0">

                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mb-1" fill="none"
                            viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <span class="ml-2 text-lg font-bold">Explicitly declare and isolate dependencies.
                        </span>
                    </p>
                </blockquote>
                <p>
                    Many programming languages offer a packaging system installer for using and sharing the code across
                    the application. Eg, node ecosystems offer NPM or Yarn, Ruby offers RubyGem, Java offers Maven or
                    Grandle, Python offers pip etc.
                </p>

                <p>Dependencies of an application are open source libraries built and distributed by developers or a
                    team or an organization. 12 Factor App said <b>“A twelve-factor app never relies on the implicit
                        existence of system-wide packages”</b>, it means all dependencies declared specific versions
                    which
                    application work in external files call manifest and use dependencies isolation tools for execution.
                    dependencies isolation tool is a tool bundler that bundles dependencies with an application.</p>

                <p> Advantages of explicit dependency declaration is helping in reusable and maintainable code base for
                    multiplapp. New developers will be able to quickly set up everything that prerequisites for
                    applications need.</p>

                <p>
                    The twelve Factor app has decouple two dependencies explicitly, it help our application do not reply
                    on implicit existence system package and system tool:
                    <div> - Versioning: by explicitly declare version dependencies</div>
                    <div> - Isolation: bundling with application during execution</div>
                </p>
                <p>Example spring boot, we explicitly declare dependencies in a <span
                        class="inline-code"><code>pom.xml</code></span>
                    file of manifest format:</p>

                <p>
                    <code class="font-mono">
                        <pre class="code">
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;
    &lt;/dependency&gt;</pre>
                    </code>
                </p>
                <p>
                    The <span class="inline-code"><code>spring-boot-starter-data-rest</code></span> is declared for
                    spring boot starter projects with restful data. It
                    will be built by a maven tool that shares class paths across an application.
                </p>


                <h2>3 - Config</h2>
                <blockquote class="blockquote bg-gray-50 text-gray-400 py-3 mb-6 rounded-sm">
                    <p class="mb-0">

                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mb-1" fill="none"
                            viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <span class="ml-2 text-lg font-bold">Store config in the environment.
                        </span>
                    </p>
                </blockquote>
                <p>
                    App config is everything as constants that running applications need on any specific environment
                    stages including database, memcached properties, third party credentials like amazon S3, firebase,
                    onesignal,..etc.
                </p>

                <p>
                    In bad practice or traditional applications, developers stored all app config variables in their
                    code. When they want to change those config, it’s hard to maintain, changing the environment and it
                    also compromises any credentials of external applications. Those are the mistakes and violence the
                    twelve-factor apps in the modern cloud for implementing the SaSS application model. So how do we
                    store config? In the config file? Yes, It’s possible but still a weakness because those config files
                    will check in to the repo.
                </p>

                <p>
                    The methodology of the twelve-factor app requires strict separation of config from code, and stores
                    config in environment variables. Environment variable (env) is convenient to change and deploy to
                    different stages without breaking the code.
                </p>

                <p>
                    The spring boot application used java system properties mechanism and offered to code in runtime by
                    configuration properties.
                </p>

                <div>
                    <code class="block">
                        application.properties
                    </code>
                    <pre class="code px-3"><code>service.mail.enable=true</code></pre>
                    <div class="mb-3"></div>
                    <pre class="code px-3"><code>
    @ConfugurationProperties(prefix = “service.mail”)
    class MailConfigProperty {
        private Boolean enabled = Boolean.TRUE;
    }</code></pre>
                </div>

                <h2>4 - Backing Services </h2>
                <blockquote class="blockquote bg-gray-50 text-gray-400 py-3 mb-6 rounded-sm">
                    <p class="mb-0">

                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mb-1" fill="none"
                            viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <span class="ml-2 text-lg font-bold">Treat backing services as attached resources.
                        </span>
                    </p>
                </blockquote>

                <p>
                    Backing service is any service that supports network operation for applications such as database,
                    messaging event, Asset service, Mail service, caching system, metrics-gathering service, …etc . Most
                    modern applications depend on backing services to operate their business.
                </p>

                <p>
                    In twelve-factor app methodology, <b>The code for a twelve factor app makes no distinction between
                        local and third party services</b>. It means both local and third party services will be
                    attached as
                    resources, and accessible via a URL. Service locator or credentials need to be stored in config to
                    comply with the config rule of twelve-factor app. Each backing service is a resource that can be
                    attached to and detached from deploy, Codebase is flexible to change local backing service to a
                    third party backing service without code changes. Example, we use local mysql in our development on
                    a local machine. When deployed we might swap to Amazon RDS third party service.
                </p>

                <p>
                    Backing service principle helps us loose coupling between app deployment and the resource. It will
                    make our application scalable and disposable.

                    Spring boot can be achieved by Spring data JPA over RDBMS data source that offers abstract
                    implementation of data access layers by configuration properties (JDBC URL) to make database
                    connection. With JPA, we can swap out databases by changing configuration.
                </p>

                <div>
                    <div class="mb-2"><code>application.properties</code></div>
                    <pre class="code">
                        <code>
    spring.jpa.hibernate.ddl-auto=update
    spring.datasource.url=jdbc:mysql://${MYSQL_HOST:localhost}:3306/db_example
    spring.datasource.username=springuser
    spring.datasource.password=ThePassword
    spring.datasource.driver-class-name =com.mysql.jdbc.Driver
    #spring.jpa.show-sql: true</code>
                    </pre>
                </div>


                <h2>5 - Build, release and run</h2>
                <blockquote class="blockquote bg-gray-50 text-gray-400 py-3 mb-6 rounded-sm">
                    <p class="mb-0">

                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mb-1" fill="none"
                            viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <span class="ml-2 text-lg font-bold">Strictly separate build and run stages.
                        </span>
                    </p>
                </blockquote>
                <p>
                    <b>“The twelve-factor app uses strict separation between the build, release, and run stages”</b>.
                    Single
                    codebase is separated three stages for deploy workflow :
                    <div>
                        - <strong>Build stage</strong> : compile source code into executable bundle.
                    </div>
                    <div>
                        - <strong>Release stage</strong> : tag unique release id and combine with deployment config for
                        execution
                        environment.
                    </div>
                    <div>- <strong>Run stage</strong>: running instance of app</div>

                </p>

                <p>
                    In the practice, we use any deployment tools for release management. eg, docker, capistrano, ..etc.
                    Those tools offer the ability to roll back previous releases. Example docker:
                    <div>- build stage: compile source code and build docker image</div>
                    <div> - release stage : annotate release version and publish docker image to docker registry.</div>
                    <div>
                        - run stage : ship docker image registry to the execution environment and run the app image.
                    </div>

                </p>

                <h2>6 - Processes</h2>
                <blockquote class="blockquote bg-gray-50 text-gray-400 py-3 mb-6 rounded-sm">
                    <p class="mb-0">

                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mb-1" fill="none"
                            viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <span class="ml-2 text-lg font-bold">Execute the app as one or more stateless process.
                        </span>
                    </p>
                </blockquote>

                <p>
                    The app is executed in the deployment environment as one or more processes. <b>“Twelve-factor
                        processes are stateless and share-nothing”</b>. It means we must not store data as stateless. If
                    the process needs the data to serve the next request we must persist data outside the application in
                    a stateful backing service, stored in a database. Why do twelve-factor apps define that ? when
                    running only one process, our application might be restarted for up deployment, changing
                    configuration, it will destroy all local state.
                </p>
                <p>
                    Some traditional web applications rely on sticky sessions that persist user data in memory to serve
                    future requests. With this scenario, it is violence of twelve-factor. Absolutely, session state
                    should be stored in a datastore with time expiration such as hazelcast or redis.
                </p>
                <p>
                    Spring boot applications execute java processes on JVM or inside containers like docker. Any data
                    that the application needs, should be stored in the database.
                </p>

                <h2>7 - Port Binding</h2>
                <blockquote class="blockquote bg-gray-50 text-gray-400 py-3 mb-6 rounded-sm">
                    <p class="mb-0">

                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mb-1" fill="none"
                            viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <span class="ml-2 text-lg font-bold">Export service vai port binding.
                        </span>
                    </p>
                </blockquote>

                <p>
                    The twelve-factor app is completely self-contained. It means the application should be binding
                    itself to a particular port and listening to all the requests from the incoming client on that port
                    in the execution environment. If you setup a web application from scratch you can use dependency
                    declaration to add a web server library to the app. In some cases, you build your web application
                    using any framework such as laravel, expressjs, or spring, it comes along with a self-contained web
                    server. The port binding methodology makes your application as the backing service for other apps to
                    consume also. It provides the URL and as attached the resource in config.
                </p>

                <p>
                    Application using spring boot embedded apache tomcat and export HTTP as a service by binding to a
                    port. We can configure the port in the config variable (.properties, yalm) <code
                        class="inline-code">server.port</code> configuration
                    property. By default spring boot serves on port 8080.
                </p>

                <h2>8 - Concurrency</h2>
                <blockquote class="blockquote bg-gray-50 text-gray-400 py-3 mb-6 rounded-sm">
                    <p class="mb-0">

                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mb-1" fill="none"
                            viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <span class="ml-2 text-lg font-bold">Scale out vai the process model.
                        </span>
                    </p>
                </blockquote>
                <p>One application can be running as one or more processes. <b>The twelve-factor app processes should be
                        scale out as horizontal scaling by process model</b>. Process model is a modern approach that
                    uses the unix process model for running web app service daeon. It gives us a unique way to manage
                    our workload and scale up overtime. In monolithic applications, it is running in a larger single
                    process that makes vertical scaling (increase CPU or RAM capacity). Best practice of the
                    methodology, If we have many processes, we should handle those processes as workloads and assign a
                    process type. For example , an application has a model assigned two process types, one process is a
                    web process that handles HTTP requests. The second, worker process is a long-running background task
                    for the job handler. Both processes are running service daemon workloads. Each of the processes
                    should be shared-nothing that makes our app easily scale faster.
                </p>
                <p>
                    Spring boot applications do not help much with this factor. Our application should be stateless and
                    managed stateful by an outside application. If we want to scale a specific process, we will split
                    our application into smaller. Microservice architecture is independent service, focus and small
                    service, including scale out processes of the nature of twelve-factor apps.
                </p>

                <h2>9 - Disposability</h2>
                <blockquote class="blockquote bg-gray-50 text-gray-400 py-3 mb-6 rounded-sm">
                    <p class="mb-0">

                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mb-1" fill="none"
                            viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <span class="ml-2 text-lg font-bold">Maximize robustness with fast startup and graceful
                            shutdown.
                        </span>
                    </p>
                </blockquote>

                <p>
                    Disposability factor means that <b>an application is able to start and stop rapidly without
                        interrupting any processes</b>. A few second startup service offers a release stage of
                    deployment easily and quickly. Processes should be shut down gracefully to allow current requests to
                    finish and exit. In case of hard shutdown, worker processes by returning the current job to the work
                    queue.
                </p>
                <p>
                    Spring boot applications should be run inside containers that can start and stop at a minimum at a
                    moment's time. Docker image should be optimized with the lazy initialization of dependencies to be a
                    disposable process.
                </p>

                <h2>10 - Dev/prod parity</h2>
                <blockquote class="blockquote bg-gray-50 text-gray-400 py-3 mb-6 rounded-sm">
                    <p class="mb-0">

                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mb-1" fill="none"
                            viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <span class="ml-2 text-lg font-bold">Keep development, staging, and production as similar as
                            possible.
                        </span>
                    </p>
                </blockquote>
                <p>Traditionally, development software applications slow down because of the divergence between dev and
                    prod infrastructure or environment.</p>
                <p><b>The twelve-factor app is designed for continuous deployment by keeping the gap between development
                        and production small and similar</b>. It helps developers continue to write code and continue to
                    deploy in hours or minutes. Besides, in the same environment, backing service is encouraged to be
                    compatible between local and production. Differences between backing services mean that they violate
                    the twelve-factor app because codebase will work on test or staging and fail in production.</p>
                <p>The container is possible to build and ship codebase packages to run everywhere and portable OS.
                    Spring boot applications are packaged in docker image and pushed to docker registry. Docker includes
                    provisioning tools of alternatives to packaging systems such as homebrew or apt-get.
                </p>

                <h2>11 - Logs</h2>
                <blockquote class="blockquote bg-gray-50 text-gray-400 py-3 mb-6 rounded-sm">
                    <p class="mb-0">

                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mb-1" fill="none"
                            viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <span class="ml-2 text-lg font-bold">Treat logs as event streams.
                        </span>
                    </p>
                </blockquote>
                <p>Log is a file that records data of all input, data output, processes or results in a program. <b>A
                        twelve-factor app never concerns itself with routing or storage of its output stream</b>. All
                    the logs shouldn't be written and stored into a log file in application. Any running process is
                    written as an event stream into the standard output stdout.</p>
                <p>Spring boot application, log only the console by default. It doesn't store log records in tmp files
                    on disk. Best practice console logs, we use SLF4J acts as a facade for different logging frameworks.
                    In a cloud environment, we can integrate any logs aggregator and management tool to analyze or
                    monitor application health such as new relics, papertrail, sentry, datadog.
                </p>

                <h2>12 - Admin processes</h2>
                <blockquote class="blockquote bg-gray-50 text-gray-400 py-3 mb-6 rounded-sm">
                    <p class="mb-0">

                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mb-1" fill="none"
                            viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <span class="ml-2 text-lg font-bold">Run admin/management tasks as one-off processes.
                        </span>
                    </p>
                </blockquote>
                <p>Most applications have one-off administrative or maintenance tasks such as database migration, script
                    fix bad record, console inspect application running. Those tasks should be run in isolated
                    processes. <b>One-off admin code must be shipped with application code to be portable in the
                        execution environment</b>. Twelve-factor app empsized run one-off script with REPL shell out of
                    the box. In local, we run shell commands inside the application. In a production environment, we can
                    remote command execution to run such a process. </p>
                <p>For spring boot applications, we add one-off admin functions and expose endpoints for invocation.</p>

                <h2>Summary</h2>
                <p>The twelve-factor app methodology is successful for developers building web applications and ops
                    engineers who deploy or manage running applications. The principle can be applied to apps, not
                    specific programming languages and ideally attach the backing service. Each of factors strongly
                    define following:
                </p>
                <p>
                    <ol>
                        <li><b>Codebase</b> : one single code base target deploy many environments.</li>
                        <li><b>Dependency</b> : All dependencies should be declared explicitly in manifest</li>
                        <li><b>Config</b> : store all configuration properties in environment variables</li>
                        <li><b>Backing Service</b> : Treat backing service as attached resource, flexible swap out by
                            execution
                            environment.</li>
                        <li><b>Build, Release, Run</b> : Delivery pipeline, build, package and run.</li>
                        <li><b>Processes</b> : run applications as stateless processes and store application data in
                            backing
                            service.</li>
                        <li><b>Port binding</b> : Self-contained and made available to other services by binding itself
                            with
                            specified port.</li>
                        <li><b>Concurrency</b> : scale out process as horizontal scaling by process model.</li>
                        <li><b>Disposability</b> : Fast startup and graceful shutdown service.</li>
                        <li><b>Dev/prod parity</b> : All environments should be as similar as possible.</li>
                        <li><b>Logs</b> : Produce logs as event stream rather than store in file inside application.
                        </li>
                        <li><b>Admin Process</b> : Admin tasks must ship with application code. </li>
                    </ol>
                </p>
                <h2>References</h2>
                <ul class="text-blue-400">
                    <li><a target="_blank" href="https://12factor.net">https://12factor.net</a></li>
                </ul>
            </article>
        </div>
    </div>

</body>

</html>